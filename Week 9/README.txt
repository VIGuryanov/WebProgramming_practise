HTML Engine Alpha version by Guryanov Vadim

Шаблонизатор распознаёт выражения, заключённые в "{{}}".
Для того, чтобы начать парсить шаблон нужно передать методу GetHTML модель - любой объект.

Шаблонизатор распознаёт только свойства модели, записанные в том же регистре.
Модель распознаётся любая, главное, чтобы у неё были все необходимые свойства. 
Например: 
	"GetHTML("{{Length}}", "a")" отработает и вернёт значение 1.
	"GetHTML("{{Sth}}", "a")" не распарсит значение и выбросит ошибку на проверке на то, что в шаблоне после парса нет пар '{{' или '}}'

К текущей модели можно обратиться используя {{this}}

Выражения в шаблоне поддерживают индексацию.
Например:
	"GetHTML("{{this[1]}}", new int[] { 0, 2 })" вернёт ответ 2
	"GetHTML("{{this[0][1][3]}}", new object[] { new string[] { "qwerty", "asdfg" }, new int[] { 0, 1 } })" вернёт 'f'

Выражения в шаблоне поддерживают вызовы свойств через точки.
Например:
	"GetHTML("{{this[0][1].Length}}", new object[] { new string[] { "qwerty", "asdfg" }, new int[] { 0, 1 } })" вернёт 5

	!!Никакие арифметические действия не поддерживаются

--------------------------------------------------------------------------------------------------

Определён цикл 'for index'. Записывается в виде
	{{for index <from> to <maxVal> step <fromIncrease>
		...
	}}
Где:
	<from>,<maxVal>,<fromIncrease> - integer в виде числа или свойства(последовательности через точку) в {{...}}
	<from> - начальный индекс,
	<maxVal> - максимальный индекс минус 1
	<fromIncrease> - шаг

При этом индекс можно получить вызовом @index

For вложенный в for работает, но во вложенном for будет использоваться внешний индекс

Пример:
	{{for index 0 to {{Students.Count}} step 1 
		<tr><td>@index</td><td>{{Students[@index].StudId}}</td><td>{{Students[@index].Surname}}</td><td>{{Students[@index].Name}}</td><td>{{Students[@index].Lastname}}</td>
	}}

--------------------------------------------------------------------------------------------------

Определён цикл 'foreach'. Записывается в виде
	{{foreach in <Property> 
		...
	}}
	!!Перенос строки после <Property> обязателен

Где:
	<Property> - свойство, известное в текущей модели или последовательность через точку.

При этом внутри foreach будет в приоритете использоваться модель типа, полученного из <Property>
то есть если базовая модель - профессор, содержащая перечислимое свойство Students с объектами Student,
то при подстановке значений сначала будет рассматриваться модель Student и только потом Professor.

Foreach вложенный в foreach работает. Наивысший приоритет для foreach имеет модель, рассматриваемая в текущем foreach. Следующая - модель блока, в котором лежит этот foreach и т.п.

Таким образом:
	var professor = new Professor("", "", "", new string[0], new string[0]);
	professor.Students.Add( new Student("","Name1", "", ""));
    professor.Students.Add(new Student("","Name2", "", ""));

    string result = new EngineHTMLService().GetHTML("{{foreach in Students\r\n {{Name}} {{foreach in Students\r\n {{Name}} }}}}",professor) 

	Вернёт:
		Name1
		Name1
		Name2
		Name2
		Name1
		Name2

--------------------------------------------------------------------------------------------------

Определён 'if'. Записывается в виде
	{{if(<expr>)
		then:
			...
		else:
			...
	}}

Где <expr> выражение, содержащее '(' ')' 'true' 'false' '!=' '=' '>' '<' '>=' '<=' '&' '&&' '|' '||' 

При этом в логическом выражении могут присутствовать свойства или выражения через точку, которые могут быть сравнимы с double или на полное совпадение string значений.
На данном этапе пробелы полностью игнорируются

Можно писать условные выражения внутри блоков then else

--------------------------------------------------------------------------------------------------

P.S
В большинстве случаев лишние пробелы, табы и переносы строки не влияют на результат, но могут возникнуть неожиданности.
Использование различных вложенных функций возможно, но 100% гарантии, что всё правильно отработает нету (Вот оно отсутствие тестов...).
К проекту прилагается файл index.template, где есть пример рабочего шаблона.